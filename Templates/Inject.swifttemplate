<%-  includeFile("Inject.swift")  %>
<%_
    /// HEADER

    let imports: [String]!

    if let _imports = (argument["imports"] as? [String]) {
      imports =  _imports
    } else if let _import = argument["imports"] as? String {
         imports = [_import]
    } else {
       imports =  []
    } 

func outputInjectFunction(injectorType :String, parentType: String, injectorProperties: [String: [Property]], useInjectorString: Bool) {
  let targetProperties = sorted(injectorProperties[injectorType] ?? [])
  let sourceProperties = injectorProperties[parentType] ?? []
  var injectorMappings: [String: String] = [:]

  log("------------------------------------------------------\n")
  log("\(parentType) -> \(injectorType) mappings:\n")
  targetProperties.forEach({targetProperty in 
    if let sourceProperty = resolvePropertyFromSource(
        property: targetProperty,
        allProperties: targetProperties,
        sourceProperties: sourceProperties
    ) {
      log("\(targetProperty.name) -> \(parentType):\(sourceProperty.name)\n")
      injectorMappings[targetProperty.name] = sourceProperty.name
    } else {
      log("\(targetProperty.name) -> ARGUMENT\n")
    } 
  }) 
  
  let arguments = targetProperties.filter({injectorMappings[$0.name] == nil})
  %>
  func inject(<%= arguments.map({"\($0.name): \($0.type)"}).joined(separator: ", ") %>) -> <%= injectorType %>Impl {
    return <%= injectorType %>Impl(
      <%= targetProperties.map({target in let mapping = injectorMappings[target.name].map({source in useInjectorString ? "injector.\(source)" : source}); return "\(target.name): \(mapping ?? target.name)"}).joined(separator: ",\n      ") %>
    )
  }
  <%
}


///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////MAIN ROUTINE/////////////////////////////////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

  let injectData = calculateInjectData()
-%>
// sourcery:file:InjectGrail/RootInjector.swift
import Foundation
<%_ for `import` in imports { -%>
import <%= `import` %>
<%_ } -%>

//Extension of RootInject which contains definition of `inject` functions creating all other Injectors.
extension <%=  injectData.rootInjector.name %> {
<%_  for type in injectData.injectors{
    outputInjectFunction(injectorType: type.name, parentType: "RootInjector", injectorProperties: injectData.injectorProperties, useInjectorString: false)
    } %>
}
// sourcery:end
// sourcery:file:InjectGrail/Injectors.swift
import Foundation
<%_ for `import` in imports { -%>
import <%= `import` %>
<%_ } -%>

<%_ 
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//Print injectors

for type in injectData.injectors{ -%>
//MARK: - <%= type.name %>
//Actual implementation of <%= type.name %> which includes all dependencies found in RootInjector and required by this injector's children.
struct <%= type.name %>Impl: <%= type.name %> {
  <%_ for property in sorted(injectData.injectorProperties[type.name] ?? []) { %>
  let <%= property.name%>: <%= property.type -%>
<%  } %>
}

<%_ } -%>
// sourcery:end
// sourcery:file:InjectGrail/Injectables.swift
import Foundation
<%_ for `import` in imports { -%>
import <%= `import` %>
<%_ } -%>

<%_ 

///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//Print inject extensions and protocols
for type in injectData.injectables { -%>
<% guard let injector = injectData.injectablesToInjectors[type.name] else { fatalError("Injector not found for \(type.name)") } %>
<% let childInjects = (injectData.injectablesToInjects[type.name] ?? [])  %>
// MARK: - <%= type.name %>
// This extension contains `inject` functions of Injectors injected by <%= type.name %>.
// That is <%= childInjects.joined(separator: ", ") %>.
// Based on the conforming to <%= childInjects.joined(separator: ", ") %>
// and  proxy variables that makes properties of <%= injector %> visible in <%= type.name %>.
extension <%= type.name %> {
<%
  let properties = sorted(injectData.injectorProperties[injector] ?? [])
  for property in properties { %> var <%= property.name %>: <%= property.type %> { return injector.<%= property.name %> } 
<%}
  for injects in childInjects { 
      guard let childInjector = injectData.injectsToInjectors[injects] else { fatalError("Child injector not found for \(injects)") }
      outputInjectFunction(injectorType: childInjector, parentType: injector, injectorProperties: injectData.injectorProperties, useInjectorString: true)
    %>
     
  <% } -%>
}

//Classes that want to inject objects of <%= type.name %> should confom to this protocol. 
//InjectGrail will extend their implementations with `inject` functions creating `<%= type.name %>Injector`
protocol Injects<%= injector %> {}

<%_ }
 -%>
// sourcery:end
