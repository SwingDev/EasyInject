import Foundation
<%_
    let imports: [String]!

    if let _imports = (argument["imports"] as? [String]) {
      imports =  _imports
    } else if let _import = argument["imports"] as? String {
         imports = [_import]
    } else {
       imports =  []
    }
-%>
<%_ for `import` in imports { -%>
import <%= `import` %>
<%_ } -%>


<%_ 

func log(_ text: String) {
    // Log.error(text)
}

struct Property {
  let name: String
  let type: String
  let forceManual: Bool
  let isSelfProperty: Bool
}

extension Property {
  func notSelf() -> Property {
    return Property(name: name, type: type, forceManual: forceManual, isSelfProperty: false)
  }
}

// Properties sorting function
func sorted(_ properties: [Property]) -> [Property] {
  return properties.enumerated()
  .sorted(by: {a, b -> Bool in 
  //Self properties go before inherited properties
  if a.element.isSelfProperty && !b.element.isSelfProperty {
    return true
  } else if !a.element.isSelfProperty && b.element.isSelfProperty {
    return false
  }

  if a.element.isSelfProperty {
    //Self properties are sorted in order they were defined
    return a.offset < b.offset
  } else {
    // Inherited properties are sorted alphabetically
     return a.element.name < b.element.name
  }
  } )
  .map { $0.element }
}

// Try to find source of the property in the list of properties available in parent
func resolvePropertyFromSource(property: Property, sourceProperties: [Property]) -> Property? {
  if (property.forceManual) {
      return nil
    }
    
  if property.type == "Int" || property.type == "String" {
    return nil
  }

  let sourcePropertiesOfSameType = sourceProperties.filter({$0.type == property.type})
  if sourcePropertiesOfSameType.count == 1 {
    return sourcePropertiesOfSameType[0]
  }

  let sourcePropertiesWithSameName = sourcePropertiesOfSameType.filter({$0.name == property.name})
  return sourcePropertiesWithSameName.first
}

func resolvePropertyFromInjectingRecursively(property: Property, injector: String, sourceProperties: [String: [Property]], injectorsToInjectorsThatInject: [String: [String]], rootProperties: [Property]) -> Property? {
      
    // Try to get property from direct parent
    let properties = sourceProperties[injector] ?? []
    if let matched = resolvePropertyFromSource(property: property, sourceProperties:properties) {
      log("RESOLVED FROM PARENT | ")
      return matched
    }

    // Try to get property from root injector
    if let matched = resolvePropertyFromSource(property: property,  sourceProperties:rootProperties) {
      log("RESOLVED FROM ROOT | ")
      return matched
    }

   // Traverse hierarchy
    for parent in (injectorsToInjectorsThatInject[injector] ?? []) {
      if let matched = resolvePropertyFromInjectingRecursively(property: property, injector: parent, sourceProperties: sourceProperties, injectorsToInjectorsThatInject: injectorsToInjectorsThatInject, rootProperties: rootProperties) {
        log("RESOLVED FROM GRAND PARENT | ")
        return matched
      }
    }
    
    log("NOT FOUND | ")
    return nil
}

func resolveDependencyTree(injectorProperties: [String: [Property]],  injectsToInjectors: [String: String], injectablesToInjectors: [String: String], injectablesToInjects: [String: [String]]) -> [String: [Property]] {
    var injectorsToInjectedInjectors: [String: [String]] = [:]
    var injectorsToInjectorsThatInject: [String: [String]] = [:]

    var injectorProperties = injectorProperties

    guard let rootInjectorProperties = injectorProperties["RootInjector"] else { fatalError("Implementation of RootInjector not found") }
    let rootPropertiesTypes = rootInjectorProperties.map {$0.type}.joined(separator: ", ")
    log("Root Injector Properties: \(rootPropertiesTypes)\n")

    // Build injection tree
    injectablesToInjects.keys.forEach({injectable in 
        guard let injector = injectablesToInjectors[injectable] else { fatalError("\(injectable) is not Injectable") }
        guard let injects = injectablesToInjects[injectable] else { fatalError("Inject not found for \(injectable)") }
        let injectedInjectors: [String] = injects.map({guard let injector = injectsToInjectors[$0] else { fatalError("Injector for \($0) not found") };  return injector})
        injectorsToInjectedInjectors[injector] = (injectorsToInjectedInjectors[injector] ?? []) + injectedInjectors
        for injected in injectedInjectors {
          injectorsToInjectorsThatInject[injected] = (injectorsToInjectorsThatInject[injected] ?? []) + [injector]
        }        
    })

    log("--------------------------\n")
    for injector in injectorsToInjectedInjectors {
        log("\(injector.key) injects:\n")
        for injected in injector.value {
          log("\t- \(injected)\n")
        }
    }
    log("--------------------------\n")

    // Find all injectors which injects doesn't inject any other injectors
    let leafInjectors = injectorProperties.keys.filter({(injectorsToInjectedInjectors[$0] == nil || injectorsToInjectedInjectors[$0]!.count == 0) && $0 != "RootInjector"})

    var injectorsToProcess: [String] = leafInjectors
    var processedInjectors: Set<String> = Set()

    // Travers injection tree from leaves upwards
    while injectorsToProcess.count > 0 {
      let injector = injectorsToProcess[0]
      injectorsToProcess.remove(at: 0)

      let  currentInjectorProperties = injectorProperties[injector] ?? []

      log("\n---\tChecking \(injector)\t---\n")

      // Starting from the leaf injectors (injectors that don't inject other injectors)
      // iterate over all injectors that inject already processed injectors to find if we need to add properties to their implementation
      let injectorsThatInjectCurrentOne = injectorsToInjectorsThatInject[injector] ?? []
      for injectorThatInjects in injectorsThatInjectCurrentOne {
        log("Injected by \(injectorThatInjects)\n")
        for property in currentInjectorProperties {
          log("\(injector):\(property.type) \t\t")
            if let matched = resolvePropertyFromInjectingRecursively(property: property, injector: injectorThatInjects, sourceProperties: injectorProperties, injectorsToInjectorsThatInject: injectorsToInjectorsThatInject, rootProperties: rootInjectorProperties) {
              if resolvePropertyFromSource(property: matched, sourceProperties: injectorProperties[injectorThatInjects] ?? []) == nil {
                //Append properties need by curren injector if not present in this injector, but found in parent or in the root
                // injectorProperties[injectorThatInjects]?.append(matched.notSelf())
                injectorProperties[injectorThatInjects] = (injectorProperties[injectorThatInjects] ?? []) + [matched.notSelf()]
              }
              log("\n")
            } else {
              log("--\n")
            }
        }
        // Make sure to append children only once
        if !processedInjectors.contains(injector) {
          injectorsToProcess.append(injectorThatInjects)
        }
      }
      processedInjectors.insert(injector)
    }

    log("------------------------------------------------------\n")
    for properties in processedInjectors {
      let list = injectorProperties[properties]?.map { $0.type }.joined(separator: ", ") ?? ""
      log("\(properties) -> \(list)\n")
    }

    return injectorProperties
}

func outputInjectFunction(injectorType :String, parentType: String, injectorProperties: [String: [Property]], useInjectorString: Bool) {
  let targetProperties = sorted(injectorProperties[injectorType] ?? [])
  let sourceProperties = injectorProperties[parentType] ?? []
  var injectorMappings: [String: String] = [:]

  log("------------------------------------------------------\n")
  log("\(parentType) -> \(injectorType) mappings:\n")
  targetProperties.forEach({targetProperty in 
    if let sourceProperty = resolvePropertyFromSource(property: targetProperty,  sourceProperties: sourceProperties) { 
      log("\(targetProperty.name) -> \(parentType):\(sourceProperty.name)\n")
      injectorMappings[targetProperty.name] = sourceProperty.name
    } else {
      log("\(targetProperty.name) -> ARGUMENT\n")
    } 
  }) 
  
  let arguments = targetProperties.filter({injectorMappings[$0.name] == nil})
  %>
  func inject(<%= arguments.map({"\($0.name): \($0.type)"}).joined(separator: ", ") %>) -> <%= injectorType %>Impl {
    return <%= injectorType %>Impl(
      <%= targetProperties.map({target in let mapping = injectorMappings[target.name].map({source in useInjectorString ? "injector.\(source)" : source}) ; return "\(target.name): \(mapping ?? target.name)"}).joined(separator: ",\n      ") %>
    )
  }
  <%
}


///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////MAIN ROUTINE/////////////////////////////////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

  let injectables = types.all.filter({ $0.inheritedTypes.contains("Injectable") })
  let injectors = types.protocols.filter({$0.inheritedTypes.contains("Injector") }) 
  var injectsToInjectors: [String: String] = [:]
  var injectablesToInjectors: [String: String] = [:]
  var injectablesToInjects: [String: [String]] = [:]
  var injectorProperties: [String: [Property]] = [:]

  //Find root injector properties
  guard let rootInjector =   types.all.first(where: {$0.inheritedTypes.contains("RootInjector")})  else { fatalError("RootInjector not found.") } 
  var rootInjectorProperties = rootInjector.storedVariables.map({Property(name: $0.name, type: "\($0.typeName)", forceManual: $0.annotations["forceManual"] != nil, isSelfProperty: false)}) ?? []

  //Find injector self properties
  injectors.forEach {injector in 
    injectsToInjectors["Injects\(injector.name)"] = injector.name; 
    injectorProperties[injector.name] = injector.instanceVariables.map({ return Property(name: $0.name, type: "\($0.typeName)", forceManual: $0.annotations["forceManual"] != nil, isSelfProperty: true)})
    return ;
  }
  
  // Build injection relation by 
  // finding which Injectors are used to init which Injectables and which Injectables inject any other Injectors
  injectables.forEach({injectable in 
    if let injectorForInjectable = injectable.storedVariables.first(where: {$0.name == "injector"})?.typeName {
      injectablesToInjectors[injectable.name] = String("\(injectorForInjectable)".dropLast(4))
    }
  
    injectablesToInjects[injectable.name] = injectable.inheritedTypes.filter({$0.hasPrefix("Injects")})
  })

  //Find properties required by all injectors (including ones required by their children and found in root injector)
  injectorProperties["RootInjector"] = rootInjectorProperties
  injectorProperties = resolveDependencyTree(injectorProperties: injectorProperties, injectsToInjectors: injectsToInjectors, injectablesToInjectors: injectablesToInjectors, injectablesToInjects: injectablesToInjects)
-%>
//Extension of RootInject which contains definition of `inject` functions creating all other Injectors.
extension <%=  rootInjector.name %> {
<%_  for type in injectors{
    outputInjectFunction(injectorType: type.name, parentType: "RootInjector", injectorProperties: injectorProperties, useInjectorString: false)
    } %>
}

<%_ 
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//Print injectors

for type in injectors{ -%>
//MARK: - <%= type.name %>
//Actual implementation of <%= type.name %> which includes all dependencies found in RootInjector and required by this injector's children.
struct <%= type.name %>Impl: <%= type.name %> {
  <%_ for property in sorted(injectorProperties[type.name] ?? []) { %>
  let <%= property.name%>: <%= property.type -%>
<%  } %>
}

<%_ } -%>

<%_ 
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//Print inject extensions and protocols

for type in injectables { -%>
<% guard let injector = injectablesToInjectors[type.name] else { fatalError("Injector not found for \(type.name)") } %>
<% let childInjects = (injectablesToInjects[type.name] ?? [])  %>
// MARK: - <%= type.name %>
// This extension contains `inject` functions of Injectors injected by <%= type.name %>.
// That is <%= childInjects.joined(separator: ", ") %>.
// Based on the conforming to <%= childInjects.joined(separator: ", ") %>
// and  proxy variables that makes properties of <%= injector %> visible in <%= type.name %>.
extension <%= type.name %> {
<%
  let properties = sorted(injectorProperties[injector] ?? [])
  for property in properties { %> var <%= property.name %>: <%= property.type %> { return injector.<%= property.name %> } 
<%}
  for injects in childInjects { 
      guard let childInjector = injectsToInjectors[injects] else { fatalError("Child injector not found for \(injects)") }
      outputInjectFunction(injectorType: childInjector, parentType: injector, injectorProperties: injectorProperties, useInjectorString: true)
    %>
     
  <% } -%>
}

//Classes that want to inject objects of <%= type.name %> should confom to this protocol. 
//InjectGrail will extend their implementations with `inject` functions creating `<%= type.name %>Injector`
protocol Injects<%= injector %> {}

<%_ } -%>

